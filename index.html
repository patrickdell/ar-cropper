<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QuickCrop</title>
  ...
</head>
<body>
  <!-- (UI unchanged, same as your file) -->

  <script>
    // (all your existing JS unchanged above)

    // track uploaded filename
    let uploadedFileName = "crop.jpg";
    function setUploadedFileName(name){
      if (!name) { uploadedFileName = "crop.jpg"; return; }
      uploadedFileName = name.replace(/\.[^/.]+$/, "") || "image";
    }

    // hook file input and drop
    fileInput.addEventListener('change', () => {
      const file = fileInput.files && fileInput.files[0];
      if (file) setUploadedFileName(file.name);
      loadFile(file);
    });
    dropZone.addEventListener('drop', (e)=>{
      e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('drop');
      const dt = e.dataTransfer; if (!dt) return;
      const file = (dt.files && dt.files[0]) || null;
      if (!file) return; if (!file.type.startsWith('image/')) { alert('Please drop an image file.'); return; }
      setUploadedFileName(file.name);
      loadFile(file);
    });

    // generate export name with suffix and counter
    const exportNameCounter = {};
    function nextExportName(){
      const base = uploadedFileName;
      if (!exportNameCounter[base]) exportNameCounter[base] = 1;
      else exportNameCounter[base]++;
      return `${base}_crop${exportNameCounter[base]===1?"":exportNameCounter[base]}.jpg`;
    }

    // replace download handler
    downloadBtn.addEventListener('click', () => {
      const outCanvas = renderCroppedToCanvas(); if (!outCanvas) { alert('Upload an image first.'); return; }
      outCanvas.toBlob(async (blob)=>{
        if(!blob){ alert('Export failed.'); return; }
        try {
          const withMeta = await attachMetadataToJpegBlob(blob, originalMetaSegments);
          const a=document.createElement('a');
          const url=URL.createObjectURL(withMeta);
          a.href=url; a.download=nextExportName();
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(()=>URL.revokeObjectURL(url), 1000);
        } catch(e){
          alert('Exported without IPTC metadata due to an error.');
          const a=document.createElement('a');
          const url=URL.createObjectURL(blob);
          a.href=url; a.download=nextExportName();
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(()=>URL.revokeObjectURL(url), 1000);
        }
      }, 'image/jpeg', 0.92);
    });

    // patch modal save too
    function schedulePreviewUpdate(){
      if (previewRAF) return;
      previewRAF = requestAnimationFrame(() => {
        previewRAF = null;
        const c = renderCroppedToCanvas();
        if (!c) return;
        c.toBlob(async (blob)=>{
          if (!blob) return;
          originalMetaSegments = buildMetaSegmentArray(originalMeta, keepExifChk.checked);
          const withMeta = await attachMetadataToJpegBlob(blob, originalMetaSegments);
          const url = URL.createObjectURL(withMeta);
          if (currentPreviewURL) URL.revokeObjectURL(currentPreviewURL);
          currentPreviewURL = url;
          modalImg.src = url;
          saveFromModal.href = url;
          saveFromModal.download = nextExportName();
        }, 'image/jpeg', 0.92);
      });
    }
  </script>
</body>
</html>
