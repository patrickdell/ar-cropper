<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QuickCrop</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#171a21">
  <style>
    :root { --bg:#0f1115; --card:#171a21; --ink:#e8eefc; --muted:#9fb0d1; --accent:#DA161F; --line:#252a36; }
    * { box-sizing: border-box; }
    body { margin: 0; font: 15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background: var(--bg); color: var(--ink); }
    .wrap { max-width: 980px; margin: 32px auto; padding: 0 16px; }
    h1 { font-size: 22px; margin: 0 0 8px; }
    p.sub { color: var(--muted); margin: 0 0 16px; }
    .card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 16px; }
    .grid { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); align-items: end; }
    label { color: var(--muted); font-size: 12px; }
    button, input[type="file"], input[type="range"] { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--line); background: #0c0f14; color: var(--ink); }
    .preset-chips { display:flex; gap:6px; flex-wrap:wrap; margin-top:6px; }
    .chip { padding:6px 10px; border:1px solid var(--line); background:#10131a; color: var(--ink); border-radius:999px; cursor:pointer; font-size:12px; }
    .chip.active { border-color: var(--accent); }
    .chip:disabled { opacity: .5; cursor: not-allowed; }
    .actions { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn { cursor: pointer; background: var(--accent); border-color: transparent; color: #fff; font-weight: 600; }
    .btn.secondary { background: #10131a; border:1px solid var(--line); color: var(--ink); }
    .preview { background:#0a0d12; border:1px solid var(--line); border-radius:12px; display:flex; align-items:center; justify-content:center; aspect-ratio: 16 / 9; position:relative; }
    canvas { max-width: 100%; height: auto; border-radius: 12px; cursor: grab; }
    canvas.dragging { cursor: grabbing; }
    .muted { color: var(--muted); }
    .zoomrow { display:flex; align-items:center; gap:10px; }
    .zoomrow output { min-width: 48px; text-align: right; color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>AR Cropper — Pan & Zoom JPG</h1>
    <p class="sub">Upload an image first. Then pick an aspect ratio, pan the crop by dragging and adjust size with the zoom. Download the cropped JPEG. <strong>No resizing/scaling of output</strong> — the export is the exact cropped pixels.</p>

    <!-- 1) Upload -->
    <div class="card" style="margin-bottom:16px;">
      <div class="grid">
        <div style="grid-column: span 12;">
          <label>Upload Image</label>
          <input id="file" type="file" accept="image/*" />
          <p class="muted" style="margin-top:6px;">JPEG/PNG/WebP supported. Drag on the preview to pan. Zoom changes the crop window size.</p>
        </div>
      </div>
    </div>

    <!-- 2) Preset + Controls + Preview -->
    <div class="card">
      <div class="grid">
        <div style="grid-column: span 12;">
          <label>Aspect Ratio</label>
          <div class="preset-chips">
            <button type="button" class="chip" data-ratio="3:2" disabled>3:2</button>
            <button type="button" class="chip" data-ratio="4:3" disabled>4:3</button>
            <button type="button" class="chip" data-ratio="1:1" disabled>1:1</button>
            <button type="button" class="chip" data-ratio="4:5" disabled>4:5</button>
            <button type="button" class="chip" data-ratio="2:3" disabled>2:3</button>
          </div>
        </div>

        <div style="grid-column: span 12;">
          <div class="preview">
            <canvas id="previewCanvas" width="960" height="540"></canvas>
          </div>
          <div class="zoomrow" style="margin-top:10px;">
            <label for="zoom" style="min-width:60px;">Zoom</label>
            <input id="zoom" type="range" min="1" max="5" step="0.01" value="1" disabled />
            <output id="zoomOut">1.00×</output>
          </div>
        </div>

        <div style="grid-column: span 12; display:flex; justify-content:flex-end;">
          <button id="download" class="btn" disabled>Download Cropped JPG</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // UI refs
    const fileInput = document.getElementById('file');
    const chips = Array.from(document.querySelectorAll('.chip'));
    const previewCanvas = document.getElementById('previewCanvas');
    const ctx = previewCanvas.getContext('2d');
    const zoom = document.getElementById('zoom');
    const zoomOut = document.getElementById('zoomOut');
    const downloadBtn = document.getElementById('download');

    // state
    let img = null;
    let ratioStr = '3:2'; // default, but disabled until upload
    let disp = { scale: 1, x: 0, y: 0 }; // image->canvas transform

    // crop state in image coords
    let cropCenter = { x: 0, y: 0 };
    let baseCrop = { w: 0, h: 0 }; // largest crop that fits at current AR

    // helpers
    function ratioToNumber(str){ const [a,b] = str.split(':').map(Number); return a>0 && b>0 ? a/b : 1; }
    function computeBaseCrop(imgW, imgH, r){ const ir = imgW/imgH; return (ir>r) ? { w: Math.round(imgH*r), h: imgH } : { w: imgW, h: Math.round(imgW/r) }; }
    function clampCropCenter(cx, cy, cw, ch, imgW, imgH){ const hw=cw/2, hh=ch/2; return { x: Math.max(hw, Math.min(imgW-hw, cx)), y: Math.max(hh, Math.min(imgH-hh, cy)) }; }

    function getCurrentCrop(){
      if (!img) return null;
      const r = ratioToNumber(ratioStr);
      baseCrop = computeBaseCrop(img.width, img.height, r);
      const z = Math.max(1, Number(zoom.value) || 1);
      const cw = Math.max(1, Math.round(baseCrop.w / z));
      const ch = Math.max(1, Math.round(baseCrop.h / z));
      const c = clampCropCenter(cropCenter.x, cropCenter.y, cw, ch, img.width, img.height);
      return { x: Math.round(c.x - cw/2), y: Math.round(c.y - ch/2), w: cw, h: ch };
    }

    function draw(){
      ctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
      ctx.fillStyle = '#0a0d12'; ctx.fillRect(0,0,previewCanvas.width, previewCanvas.height);
      if (!img) return;
      // fit image into canvas
      disp.scale = Math.min(previewCanvas.width/img.width, previewCanvas.height/img.height);
      const dispW = img.width*disp.scale, dispH = img.height*disp.scale;
      disp.x = (previewCanvas.width - dispW)/2; disp.y = (previewCanvas.height - dispH)/2;
      ctx.drawImage(img, disp.x, disp.y, dispW, dispH);
      // overlay mask
      ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(0,0,previewCanvas.width,previewCanvas.height);
      const crop = getCurrentCrop(); if (!crop) return;
      const cx = disp.x + crop.x*disp.scale, cy = disp.y + crop.y*disp.scale;
      const cw = crop.w*disp.scale, ch = crop.h*disp.scale;
      ctx.save(); ctx.globalCompositeOperation = 'destination-out'; ctx.fillRect(cx, cy, cw, ch); ctx.restore();
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(cx, cy, cw, ch);
    }

    function enableControls(){ chips.forEach(c=>c.disabled=false); zoom.disabled=false; downloadBtn.disabled=false; }
    function resetCrop(){ if (!img) return; cropCenter = { x: img.width/2, y: img.height/2 }; zoom.value = 1; zoomOut.textContent = '1.00×'; }

    // interactions
    chips.forEach(btn => btn.addEventListener('click', () => { ratioStr = btn.dataset.ratio; chips.forEach(c=>c.classList.toggle('active', c===btn)); resetCrop(); draw(); }));
    zoom.addEventListener('input', () => { zoomOut.textContent = `${Number(zoom.value).toFixed(2)}×`; draw(); });

    let dragging=false, dragOffset={x:0,y:0};
    previewCanvas.addEventListener('mousedown', (e)=>{
      if(!img) return; dragging=true; previewCanvas.classList.add('dragging');
      const rect=previewCanvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      const ix=(mx - disp.x)/disp.scale, iy=(my - disp.y)/disp.scale; const crop=getCurrentCrop(); if(!crop) return;
      dragOffset.x = ix - (crop.x + crop.w/2); dragOffset.y = iy - (crop.y + crop.h/2);
    });
    window.addEventListener('mouseup',()=>{dragging=false; previewCanvas.classList.remove('dragging');});
    window.addEventListener('mousemove',(e)=>{
      if(!dragging||!img) return; const rect=previewCanvas.getBoundingClientRect();
      const ix=(e.clientX-rect.left - disp.x)/disp.scale, iy=(e.clientY-rect.top - disp.y)/disp.scale; const crop=getCurrentCrop(); if(!crop) return;
      const targetCenterX = ix - dragOffset.x, targetCenterY = iy - dragOffset.y;
      const clamped = clampCropCenter(targetCenterX, targetCenterY, crop.w, crop.h, img.width, img.height);
      cropCenter.x = clamped.x; cropCenter.y = clamped.y; draw();
    });

    // file handling
    fileInput.addEventListener('change', () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) { img=null; draw(); return; }
      const url = URL.createObjectURL(file);
      const image = new Image();
      image.onload = () => { URL.revokeObjectURL(url); img=image; enableControls(); chips[0].click(); draw(); };
      image.onerror = () => { URL.revokeObjectURL(url); alert('Failed to load image.'); };
      image.src = url;
    });

    // export (no resizing — canvas size = crop size)
    downloadBtn.addEventListener('click', () => {
      if (!img) { alert('Upload an image first.'); return; }
      const crop = getCurrentCrop(); if (!crop) return;
      const outCanvas = document.createElement('canvas'); outCanvas.width = crop.w; outCanvas.height = crop.h;
      const octx = outCanvas.getContext('2d'); octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality = 'high';
      octx.drawImage(img, crop.x, crop.y, crop.w, crop.h, 0, 0, crop.w, crop.h);
      outCanvas.toBlob((blob)=>{
        if(!blob){ alert('Export failed.'); return; }
        const a=document.createElement('a'); const url=URL.createObjectURL(blob); a.href=url; a.download=`crop_${crop.w}x${crop.h}.jpg`;
        document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
      }, 'image/jpeg', 0.92);
    });

    // initial paint
    draw();
  </script>
</body>
</html>
