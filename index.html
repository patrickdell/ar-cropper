<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QuickCrop</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#171a21">
  <style>
    :root { --bg:#0f1115; --card:#171a21; --ink:#e8eefc; --muted:#9fb0d1; --accent:#DA161F; --line:#252a36; }
    * { box-sizing: border-box; }
    body { margin: 0; font: 15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background: var(--bg); color: var(--ink); }
    .wrap { max-width: 980px; margin: 32px auto; padding: 0 16px; }
    h1 { font-size: 22px; margin: 0 0 8px; }
    p.sub { color: var(--muted); margin: 0 0 16px; }
    .card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 16px; }
    .grid { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); align-items: end; }
    label { color: var(--muted); font-size: 12px; }
    button, input[type="file"], input[type="range"] { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--line); background: #0c0f14; color: var(--ink); }
    .preset-chips { display:flex; gap:6px; flex-wrap:wrap; margin-top:6px; }
    .chip { padding:6px 10px; border:1px solid var(--line); background:#10131a; color: var(--ink); border-radius:999px; cursor:pointer; font-size:12px; }
    .chip.active { border-color: var(--accent); }
    .chip:disabled { opacity: .5; cursor: not-allowed; }
    .btn { cursor: pointer; background: var(--accent); border-color: transparent; color: #fff; font-weight: 600; }
    .btn.secondary { background: #10131a; border:1px solid var(--line); color: var(--ink); }
    .btn.ghost { background: transparent; border:1px dashed var(--line); color: var(--ink); }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .preview { background:#0a0d12; border:1px solid var(--line); border-radius:12px; display:flex; align-items:center; justify-content:center; aspect-ratio: 16 / 9; position:relative; }
    canvas { max-width: 100%; height: auto; border-radius: 12px; cursor: grab; }
    canvas.dragging { cursor: grabbing; }
    .muted { color: var(--muted); }
    .zoomrow { display:flex; align-items:center; gap:10px; }
    .zoomrow output { min-width: 48px; text-align: right; color: var(--muted); }
    /* modal */
    .modal { position: fixed; inset: 0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,0.6); z-index: 1000; }
    .modal.show { display:flex; }
    .modal-card { background: #0f131a; border:1px solid var(--line); border-radius: 14px; max-width: 90vw; max-height: 90vh; padding: 12px; }
    .modal-card img { max-width: 85vw; max-height: 80vh; display:block; border-radius: 10px; }
    .modal-actions { display:flex; justify-content:flex-end; gap:8px; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>QuickCrop</h1>
    <p class="sub">Upload an image, choose an aspect ratio, pan the crop by dragging or arrow keys and zoom with mouse wheel or slider. Preview, then download the cropped JPEG. <strong>No resizing/scaling of output</strong> — export is exact cropped pixels. IPTC/EXIF is preserved from source JPEG.</p>

    <!-- 1) Upload -->
    <div class="card" style="margin-bottom:16px;">
      <div class="grid">
        <div style="grid-column: span 12;">
          <label>Upload Image</label>
          <input id="file" type="file" accept="image/*" />
          <p class="muted" style="margin-top:6px;">Drag on the preview to pan. Mouse wheel to zoom. Arrow keys to nudge. Shift+arrows for larger steps.</p>
        </div>
      </div>
    </div>

    <!-- 2) Preset + Controls + Preview -->
    <div class="card">
      <div class="grid">
        <div style="grid-column: span 12;">
          <label>Aspect Ratio</label>
          <div class="preset-chips">
            <button type="button" class="chip" data-ratio="3:2" disabled>3:2</button>
            <button type="button" class="chip" data-ratio="4:3" disabled>4:3</button>
            <button type="button" class="chip" data-ratio="1:1" disabled>1:1</button>
            <button type="button" class="chip" data-ratio="4:5" disabled>4:5</button>
            <button type="button" class="chip" data-ratio="2:3" disabled>2:3</button>
          </div>
        </div>

        <div style="grid-column: span 12;">
          <div class="preview">
            <canvas id="previewCanvas" width="960" height="540"></canvas>
          </div>
          <div class="zoomrow" style="margin-top:10px;">
            <label for="zoom" style="min-width:60px;">Zoom</label>
            <input id="zoom" type="range" min="1" max="5" step="0.01" value="1" disabled />
            <output id="zoomOut">1.00×</output>
          </div>
        </div>

        <div style="grid-column: span 12; display:flex; justify-content:space-between; gap:8px;">
          <div class="row">
            <button id="undoBtn" class="btn secondary" disabled>Undo</button>
            <button id="startOverBtn" class="btn ghost" disabled>Start Over</button>
          </div>
          <div class="row">
            <button id="previewBtn" class="btn secondary" disabled>Preview</button>
            <button id="downloadBtn" class="btn" disabled>Download Cropped JPG</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal Preview -->
  <div id="modal" class="modal" aria-hidden="true">
    <div class="modal-card">
      <img id="modalImg" alt="Cropped preview" />
      <div class="modal-actions">
        <button id="closeModal" class="btn secondary">Close</button>
        <a id="saveFromModal" class="btn" download="crop.jpg">Download JPG</a>
      </div>
    </div>
  </div>

  <script>
    // UI refs
    const fileInput = document.getElementById('file');
    const chips = Array.from(document.querySelectorAll('.chip'));
    const previewCanvas = document.getElementById('previewCanvas');
    const ctx = previewCanvas.getContext('2d');
    const zoom = document.getElementById('zoom');
    const zoomOut = document.getElementById('zoomOut');

    const previewBtn = document.getElementById('previewBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const undoBtn = document.getElementById('undoBtn');
    const startOverBtn = document.getElementById('startOverBtn');

    const modal = document.getElementById('modal');
    const modalImg = document.getElementById('modalImg');
    const closeModal = document.getElementById('closeModal');
    const saveFromModal = document.getElementById('saveFromModal');

    // metadata capture to preserve IPTC/EXIF/XMP/ICC (JPEG only)
    let originalMetaSegments = [];

    // state
    let img = null;
    let ratioStr = '3:2'; // default, but disabled until upload
    let disp = { scale: 1, x: 0, y: 0 }; // image->canvas transform

    // crop state in image coords
    let cropCenter = { x: 0, y: 0 };
    let baseCrop = { w: 0, h: 0 }; // largest crop that fits at current AR

    // preview modal live-update state
    let previewOpen = false;
    let previewRAF = null;
    let currentPreviewURL = null;

    // simple history for Undo
    const history = [];
    function pushHistory(){ if(!img) return; const state = { ratioStr, cropCenter: { ...cropCenter }, zoom: Number(zoom.value) }; history.push(state); undoBtn.disabled = history.length === 0; }
    function popHistory(){ const prev = history.pop(); undoBtn.disabled = history.length === 0; return prev || null; }

    // helpers
    function ratioToNumber(str){ const [a,b] = str.split(':').map(Number); return a>0 && b>0 ? a/b : 1; }
    function computeBaseCrop(imgW, imgH, r){ const ir = imgW/imgH; return (ir>r) ? { w: Math.round(imgH*r), h: imgH } : { w: imgW, h: Math.round(imgW/r) }; }
    function clampCropCenter(cx, cy, cw, ch, imgW, imgH){ const hw=cw/2, hh=ch/2; return { x: Math.max(hw, Math.min(imgW-hw, cx)), y: Math.max(hh, Math.min(imgH-hh, cy)) }; }

    function getCurrentCrop(){
      if (!img) return null;
      const r = ratioToNumber(ratioStr);
      baseCrop = computeBaseCrop(img.width, img.height, r);
      const z = Math.max(1, Number(zoom.value) || 1);
      const cw = Math.max(1, Math.round(baseCrop.w / z));
      const ch = Math.max(1, Math.round(baseCrop.h / z));
      const c = clampCropCenter(cropCenter.x, cropCenter.y, cw, ch, img.width, img.height);
      return { x: Math.round(c.x - cw/2), y: Math.round(c.y - ch/2), w: cw, h: ch };
    }

    function draw(){
      ctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
      ctx.fillStyle = '#0a0d12'; ctx.fillRect(0,0,previewCanvas.width, previewCanvas.height);
      if (!img) return;
      // fit image into canvas
      disp.scale = Math.min(previewCanvas.width/img.width, previewCanvas.height/img.height);
      const dispW = img.width*disp.scale, dispH = img.height*disp.scale;
      disp.x = (previewCanvas.width - dispW)/2; disp.y = (previewCanvas.height - dispH)/2;
      ctx.drawImage(img, disp.x, disp.y, dispW, dispH);
      // overlay mask
      ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(0,0,previewCanvas.width,previewCanvas.height);
      const crop = getCurrentCrop(); if (!crop) return;
      const cx = disp.x + crop.x*disp.scale, cy = disp.y + crop.y*disp.scale;
      const cw = crop.w*disp.scale, ch = crop.h*disp.scale;
      ctx.save(); ctx.globalCompositeOperation = 'destination-out'; ctx.fillRect(cx, cy, cw, ch); ctx.restore();
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(cx, cy, cw, ch);
      if (previewOpen) schedulePreviewUpdate();
    }

    function enableControls(){ chips.forEach(c=>c.disabled=false); zoom.disabled=false; downloadBtn.disabled=false; previewBtn.disabled=false; startOverBtn.disabled=false; }
    function resetCrop(){ if (!img) return; cropCenter = { x: img.width/2, y: img.height/2 }; zoom.value = 1; zoomOut.textContent = '1.00×'; }

    // interactions — aspect ratio
    chips.forEach(btn => btn.addEventListener('click', () => { pushHistory(); ratioStr = btn.dataset.ratio; chips.forEach(c=>c.classList.toggle('active', c===btn)); resetCrop(); draw(); }));

    // interactions — slider zoom
    zoom.addEventListener('input', () => { pushHistory(); zoomOut.textContent = `${Number(zoom.value).toFixed(2)}×`; draw(); });

    // interactions — drag to pan
    let dragging=false, dragOffset={x:0,y:0};
    previewCanvas.addEventListener('mousedown', (e)=>{
      if(!img) return; dragging=true; previewCanvas.classList.add('dragging');
      const rect=previewCanvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      const ix=(mx - disp.x)/disp.scale, iy=(my - disp.y)/disp.scale; const crop=getCurrentCrop(); if(!crop) return;
      dragOffset.x = ix - (crop.x + crop.w/2); dragOffset.y = iy - (crop.y + crop.h/2);
      pushHistory();
    });
    window.addEventListener('mouseup',()=>{dragging=false; previewCanvas.classList.remove('dragging');});
    window.addEventListener('mousemove',(e)=>{
      if(!dragging||!img) return; const rect=previewCanvas.getBoundingClientRect();
      const ix=(e.clientX-rect.left - disp.x)/disp.scale, iy=(e.clientY-rect.top - disp.y)/disp.scale; const crop=getCurrentCrop(); if(!crop) return;
      const targetCenterX = ix - dragOffset.x, targetCenterY = iy - dragOffset.y;
      const clamped = clampCropCenter(targetCenterX, targetCenterY, crop.w, crop.h, img.width, img.height);
      cropCenter.x = clamped.x; cropCenter.y = clamped.y; draw();
    });

    // interactions — mouse wheel / touchpad zoom (center on cursor)
    previewCanvas.addEventListener('wheel', (e)=>{
      if(!img) return; e.preventDefault();
      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      const oldZ = Number(zoom.value);
      let newZ = Math.min(5, Math.max(1, oldZ * factor));
      if (Math.abs(newZ - oldZ) < 1e-3) return;
      const rect=previewCanvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      const ix=(mx - disp.x)/disp.scale, iy=(my - disp.y)/disp.scale;
      const crop=getCurrentCrop(); if(!crop) return;
      const fx = (ix - crop.x) / crop.w; const fy = (iy - crop.y) / crop.h;
      // apply zoom
      pushHistory();
      zoom.value = newZ; zoomOut.textContent = `${Number(zoom.value).toFixed(2)}×`;
      const after = getCurrentCrop();
      let x0p = ix - fx * after.w; let y0p = iy - fy * after.h;
      const centerX = x0p + after.w/2; const centerY = y0p + after.h/2;
      const clamped = clampCropCenter(centerX, centerY, after.w, after.h, img.width, img.height);
      cropCenter.x = clamped.x; cropCenter.y = clamped.y;
      draw();
    }, { passive:false });

    // interactions — keyboard pan + zoom
    window.addEventListener('keydown', (e)=>{
      if(!img) return;
      const activeTag = document.activeElement && document.activeElement.tagName.toLowerCase();
      if (activeTag === 'input' || activeTag === 'textarea') return;
      const crop = getCurrentCrop(); if(!crop) return;
      const baseStep = Math.max(1, Math.round(Math.min(crop.w, crop.h) * 0.02));
      const step = e.shiftKey ? baseStep * 3 : baseStep;
      let handled = true;
      switch(e.key){
        case 'ArrowLeft': pushHistory(); cropCenter.x = Math.max(crop.w/2, cropCenter.x - step); break;
        case 'ArrowRight': pushHistory(); cropCenter.x = Math.min(img.width - crop.w/2, cropCenter.x + step); break;
        case 'ArrowUp': pushHistory(); cropCenter.y = Math.max(crop.h/2, cropCenter.y - step); break;
        case 'ArrowDown': pushHistory(); cropCenter.y = Math.min(img.height - crop.h/2, cropCenter.y + step); break;
        case '+': case '=': pushHistory(); zoom.value = Math.min(5, Number(zoom.value)*1.1); zoomOut.textContent = `${Number(zoom.value).toFixed(2)}×`; break;
        case '-': case '_': pushHistory(); zoom.value = Math.max(1, Number(zoom.value)/1.1); zoomOut.textContent = `${Number(zoom.value).toFixed(2)}×`; break;
        default: handled = false;
      }
      if (handled){ e.preventDefault(); draw(); }
    });

    // file handling
    fileInput.addEventListener('change', () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) { clearToStart(); return; }
      const url = URL.createObjectURL(file);
      const image = new Image();
      image.onload = async () => { URL.revokeObjectURL(url); img=image; enableControls(); chips.forEach(c=>c.classList.remove('active')); chips[0].classList.add('active'); ratioStr = chips[0].dataset.ratio; resetCrop(); history.length=0; draw();
        try { const buf = await file.arrayBuffer(); originalMetaSegments = extractJpegMetaSegments(buf); } catch(e) { originalMetaSegments = []; }
      };
      image.onerror = () => { URL.revokeObjectURL(url); alert('Failed to load image.'); };
      image.src = url;
    });

    function clearToStart(){
      img=null; history.length=0; ctx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
      chips.forEach(c=>{ c.disabled=true; c.classList.remove('active'); });
      if (chips[0]) chips[0].classList.add('active');
      ratioStr = chips[0] ? chips[0].dataset.ratio : '3:2';
      zoom.value = 1; zoomOut.textContent = '1.00×';
      downloadBtn.disabled = true; previewBtn.disabled = true; startOverBtn.disabled = true; undoBtn.disabled = true; zoom.disabled = true;
    }

    // export helpers
    function renderCroppedToCanvas(){
      if (!img) return null;
      const crop = getCurrentCrop(); if (!crop) return null;
      const outCanvas = document.createElement('canvas'); outCanvas.width = crop.w; outCanvas.height = crop.h;
      const octx = outCanvas.getContext('2d'); octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality = 'high';
      octx.drawImage(img, crop.x, crop.y, crop.w, crop.h, 0, 0, crop.w, crop.h);
      return outCanvas;
    }

    // ---- JPEG metadata handling (focus on IPTC + XMP only to avoid Orientation issues) ----
    function extractJpegMetaSegments(buffer){
      // Keep only APP13 (Photoshop IPTC) and APP1 XMP packets. Skip EXIF to avoid double-rotation issues.
      const view = new DataView(buffer);
      const u8 = new Uint8Array(buffer);
      const segs = [];
      if (u8.length < 4 || u8[0] !== 0xFF || u8[1] !== 0xD8) return segs; // not JPEG
      let i = 2; // after SOI
      while (i + 4 <= u8.length){
        if (u8[i] !== 0xFF) { i++; continue; }
        while (i < u8.length && u8[i] === 0xFF) i++;
        if (i >= u8.length) break;
        const marker = u8[i++];
        if (marker === 0xDA /*SOS*/ || marker === 0xD9 /*EOI*/) break;
        if (i + 2 > u8.length) break;
        const len = view.getUint16(i, false);
        const segStart = i - 2; // at 0xFF
        const segEnd = i + len;
        if (segEnd > u8.length) break;
        if ((marker & 0xF0) === 0xE0){
          if (marker === 0xED){ // APP13 (IPTC/Photoshop)
            // Confirm signature "Photoshop 3.0 "
            const sig = "Photoshop 3.0 ";
            let ok = true; for (let k=0;k<sig.length && (i+2+k)<segEnd;k++){ if (u8[i+2+k] !== sig.charCodeAt(k)) { ok=false; break; } }
            if (ok) segs.push(u8.slice(segStart, segEnd));
          } else if (marker === 0xE1){ // APP1 (Exif or XMP)
            // XMP packets start with "http://ns.adobe.com/xap/1.0/ "
            const xmpSig = "http://ns.adobe.com/xap/1.0/ ";
            let isXmp = true; for (let k=0;k<xmpSig.length && (i+2+k)<segEnd;k++){ if (u8[i+2+k] !== xmpSig.charCodeAt(k)) { isXmp=false; break; } }
            if (isXmp) segs.push(u8.slice(segStart, segEnd));
            // NOTE: deliberately skipping EXIF to prevent orientation tag conflicts
          }
        }
        i = segEnd;
      }
      return segs;
    }

    async function attachMetadataToJpegBlob(blob, metaSegments){
      // Insert our metadata after any existing APP0 (JFIF) in the encoded JPEG
      if (!metaSegments || metaSegments.length === 0) return blob;
      const outBuf = await blob.arrayBuffer();
      const u8 = new Uint8Array(outBuf);
      if (u8.length < 4 || u8[0] !== 0xFF || u8[1] !== 0xD8) return blob;
      let insertPos = 2; // after SOI
      // If canvas encoder emitted APP0 JFIF, skip it so JFIF stays first
      if (u8[2] === 0xFF && u8[3] === 0xE0 && u8.length >= 6){
        const len = (u8[4] << 8) | u8[5];
        if (6 + len <= u8.length) insertPos = 2 + 2 + len; // SOI + (0xFF E0 + len + data)
      }
      const metaLen = metaSegments.reduce((sum, seg) => sum + seg.length, 0);
      const merged = new Uint8Array(u8.length + metaLen);
      // copy: before insert
      merged.set(u8.subarray(0, insertPos), 0);
      // copy: meta
      let off = insertPos;
      for (const seg of metaSegments){ merged.set(seg, off); off += seg.length; }
      // copy: rest
      merged.set(u8.subarray(insertPos), off);
      return new Blob([merged], { type: 'image/jpeg' });
    }

    function schedulePreviewUpdate(){
      if (previewRAF) return;
      previewRAF = requestAnimationFrame(() => {
        previewRAF = null;
        const c = renderCroppedToCanvas();
        if (!c) return;
        c.toBlob(async (blob)=>{
          if (!blob) return;
          const withMeta = await attachMetadataToJpegBlob(blob, originalMetaSegments);
          const url = URL.createObjectURL(withMeta);
          if (currentPreviewURL) URL.revokeObjectURL(currentPreviewURL);
          currentPreviewURL = url;
          modalImg.src = url; saveFromModal.href = url;
        }, 'image/jpeg', 0.92);
      });
    }

    // Preview modal
    function openPreview(){
      previewOpen = true;
      schedulePreviewUpdate();
      modal.classList.add('show');
      modal.setAttribute('aria-hidden','false');
    }
    previewBtn.addEventListener('click', openPreview);
    closeModal.addEventListener('click', ()=>{
      modal.classList.remove('show');
      modal.setAttribute('aria-hidden','true');
      previewOpen = false;
      if (currentPreviewURL) { URL.revokeObjectURL(currentPreviewURL); currentPreviewURL = null; }
      modalImg.src='';
    });
    modal.addEventListener('click', (e)=>{ if(e.target===modal) { closeModal.click(); } });

    // Download (no resizing)
    downloadBtn.addEventListener('click', () => {
      const outCanvas = renderCroppedToCanvas(); if (!outCanvas) { alert('Upload an image first.'); return; }
      outCanvas.toBlob(async (blob)=>{
        if(!blob){ alert('Export failed.'); return; }
        try {
          const withMeta = await attachMetadataToJpegBlob(blob, originalMetaSegments);
          const a=document.createElement('a'); const url=URL.createObjectURL(withMeta); a.href=url; a.download='crop.jpg';
          document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
        } catch(e){
          alert('Exported without IPTC metadata due to an error.');
          const a=document.createElement('a'); const url=URL.createObjectURL(blob); a.href=url; a.download='crop.jpg';
          document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
        }
      }, 'image/jpeg', 0.92);
    });

    // Undo & Start Over
    undoBtn.addEventListener('click', ()=>{
      const prev = popHistory(); if (!prev) return;
      ratioStr = prev.ratioStr; chips.forEach(c=>c.classList.toggle('active', c.dataset.ratio===ratioStr));
      cropCenter = { ...prev.cropCenter }; zoom.value = prev.zoom; zoomOut.textContent = `${Number(zoom.value).toFixed(2)}×`;
      draw();
    });

    startOverBtn.addEventListener('click', ()=>{ clearToStart(); });

    // initial paint
    draw();
  </script>
</body>
</html>
